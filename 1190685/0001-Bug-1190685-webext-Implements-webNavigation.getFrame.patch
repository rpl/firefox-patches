# HG changeset patch
# User Luca Greco <luca.greco@alcacoop.it>
# Date 1454415552 -3600
#      Tue Feb 02 13:19:12 2016 +0100
# Node ID fbccc900409085c1205fc0e88e48924cabb93dfa
# Parent  ced4e3f6c8bcf408df4a4f35b69f1c4d40ee7cb2
Bug 1190685 - [webext] Implements webNavigation.getFrame/getAllFrames API methods. r=kmag

diff --git a/toolkit/components/extensions/ExtensionContent.jsm b/toolkit/components/extensions/ExtensionContent.jsm
--- a/toolkit/components/extensions/ExtensionContent.jsm
+++ b/toolkit/components/extensions/ExtensionContent.jsm
@@ -29,16 +29,19 @@ XPCOMUtils.defineLazyModuleGetter(this, 
                                   "resource://gre/modules/MatchPattern.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "PrivateBrowsingUtils",
                                   "resource://gre/modules/PrivateBrowsingUtils.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "PromiseUtils",
                                   "resource://gre/modules/PromiseUtils.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "MessageChannel",
                                   "resource://gre/modules/MessageChannel.jsm");
 
+XPCOMUtils.defineLazyModuleGetter(this, "WebNavigationFrames",
+                                  "resource://gre/modules/WebNavigationFrames.jsm");
+
 Cu.import("resource://gre/modules/ExtensionUtils.jsm");
 var {
   runSafeSyncWithoutClone,
   BaseContext,
   LocaleData,
   MessageBroker,
   Messenger,
   injectAPI,
@@ -663,16 +666,18 @@ ExtensionManager = {
 };
 
 class ExtensionGlobal {
   constructor(global) {
     this.global = global;
 
     MessageChannel.addListener(global, "Extension:Capture", this);
     MessageChannel.addListener(global, "Extension:Execute", this);
+    MessageChannel.addListener(global, "WebNavigation:GetFrame", this);
+    MessageChannel.addListener(global, "WebNavigation:GetAllFrames", this);
 
     this.broker = new MessageBroker([global]);
 
     this.windowId = global.content
                           .QueryInterface(Ci.nsIInterfaceRequestor)
                           .getInterface(Ci.nsIDOMWindowUtils)
                           .outerWindowID;
 
@@ -712,24 +717,46 @@ class ExtensionGlobal {
                   canvas.height / win.innerHeight);
 
         ctx.drawWindow(win, win.scrollX, win.scrollY, win.innerWidth, win.innerHeight, "#fff");
 
         return canvas.toDataURL(`image/${data.options.format}`,
                                 data.options.quality / 100);
 
       case "Extension:Execute":
-        let deferred = PromiseUtils.defer();
+        return this.handleExtensionExecute(target, recipient, data);
+      case "WebNavigation:GetFrame":
+        return this.handleWebNavigationGetFrame(data);
+      case "WebNavigation:GetAllFrames":
+        return this.handleWebNavigationGetAllFrames(data);
+    }
 
-        let script = new Script(data.options, deferred);
-        let { extensionId } = recipient;
-        DocumentManager.executeScript(target, extensionId, script);
+    let deferred = PromiseUtils.defer();
+    deferred.reject("Unknown message name");
+    return deferred.promise;
+  }
 
-        return deferred.promise;
-    }
+  handleExtensionExecute(target, recipient, data) {
+    let deferred = PromiseUtils.defer();
+    let script = new Script(data.options, deferred);
+    let { extensionId } = recipient;
+    DocumentManager.executeScript(target, extensionId, script);
+    return deferred.promise;
+  }
+
+  handleWebNavigationGetFrame(data) {
+    let deferred = PromiseUtils.defer();
+    deferred.resolve(WebNavigationFrames.getFrame(this.global.docShell, data));
+    return deferred.promise;
+  }
+
+  handleWebNavigationGetAllFrames(data) {
+    let deferred = PromiseUtils.defer();
+    deferred.resolve(WebNavigationFrames.getAllFrames(this.global.docShell, data));
+    return deferred.promise;
   }
 }
 
 this.ExtensionContent = {
   globals: new Map(),
 
   init(global) {
     this.globals.set(global, new ExtensionGlobal(global));
diff --git a/toolkit/components/extensions/ext-webNavigation.js b/toolkit/components/extensions/ext-webNavigation.js
--- a/toolkit/components/extensions/ext-webNavigation.js
+++ b/toolkit/components/extensions/ext-webNavigation.js
@@ -55,21 +55,61 @@ function WebNavigationEventManager(conte
     };
   };
 
   return SingletonEventManager.call(this, context, name, register);
 }
 
 WebNavigationEventManager.prototype = Object.create(SingletonEventManager.prototype);
 
+function convertGetFrameResult(tabId, data) {
+  return {
+    errorOccurred: data.errorOccurred,
+    url: data.url,
+    tabId,
+    frameId: ExtensionManagement.getFrameId(data.windowId),
+    parentFrameId: ExtensionManagement.getParentFrameId(data.parentWindowId, data.windowId),
+  };
+}
+
 extensions.registerSchemaAPI("webNavigation", "webNavigation", (extension, context) => {
   return {
     webNavigation: {
       onBeforeNavigate: new WebNavigationEventManager(context, "onBeforeNavigate").api(),
       onCommitted: new WebNavigationEventManager(context, "onCommitted").api(),
       onDOMContentLoaded: new WebNavigationEventManager(context, "onDOMContentLoaded").api(),
       onCompleted: new WebNavigationEventManager(context, "onCompleted").api(),
       onErrorOccurred: new WebNavigationEventManager(context, "onErrorOccurred").api(),
       onReferenceFragmentUpdated: new WebNavigationEventManager(context, "onReferenceFragmentUpdated").api(),
       onCreatedNavigationTarget: ignoreEvent(context, "webNavigation.onCreatedNavigationTarget"),
+      getAllFrames(details, callback) {
+        let tab = TabManager.getTab(details.tabId);
+        if (!tab) {
+          // TODO: check if runtime.lastError should be set
+          return context.wrapPromise(Promise.resolve([[]]), callback);
+        }
+
+        let { innerWindowID, messageManager } = tab.linkedBrowser;
+        let recipient = { innerWindowID };
+
+        let promise = context.sendMessage(messageManager, "WebNavigation:GetAllFrames", details, recipient)
+                             .then((results) => [results.map(convertGetFrameResult.bind(null, details.tabId))]);
+        return context.wrapPromise(promise, callback);
+      },
+      getFrame(details, callback) {
+        let tab = TabManager.getTab(details.tabId);
+        if (!tab) {
+          // TODO: check if runtime.lastError should be set
+          return context.wrapPromise(Promise.resolve([undefined]), callback);
+        }
+
+        let recipient = {
+          innerWindowID: tab.linkedBrowser.innerWindowID,
+        };
+
+        let mm = tab.linkedBrowser.messageManager;
+        let promise = context.sendMessage(mm, "WebNavigation:GetFrame", details, recipient)
+              .then((result) => [convertGetFrameResult(details.tabId, result)]);
+        return context.wrapPromise(promise, callback);
+      },
     },
   };
 });
diff --git a/toolkit/components/extensions/schemas/web_navigation.json b/toolkit/components/extensions/schemas/web_navigation.json
--- a/toolkit/components/extensions/schemas/web_navigation.json
+++ b/toolkit/components/extensions/schemas/web_navigation.json
@@ -31,28 +31,28 @@
         "id": "TransitionQualifier",
         "type": "string",
         "enum": ["client_redirect", "server_redirect", "forward_back", "from_address_bar"]
       }
     ],
     "functions": [
       {
         "name": "getFrame",
-        "unsupported": true,
+        "unsupported": false,
         "type": "function",
         "description": "Retrieves information about the given frame. A frame refers to an &lt;iframe&gt; or a &lt;frame&gt; of a web page and is identified by a tab ID and a frame ID.",
         "async": "callback",
         "parameters": [
           {
             "type": "object",
             "name": "details",
             "description": "Information about the frame to retrieve information about.",
             "properties": {
               "tabId": { "type": "integer", "minimum": 0, "description": "The ID of the tab in which the frame is." },
-              "processId": {"unsupported": true, "type": "integer", "description": "The ID of the process runs the renderer for this tab."},
+              "processId": {"unsupported": false, "type": "integer", "description": "The ID of the process runs the renderer for this tab."},
               "frameId": { "type": "integer", "minimum": 0, "description": "The ID of the frame in the given tab." }
             }
           },
           {
             "type": "function",
             "name": "callback",
             "parameters": [
               {
@@ -76,17 +76,17 @@
                 }
               }
             ]
           }
         ]
       },
       {
         "name": "getAllFrames",
-        "unsupported": true,
+        "unsupported": false,
         "type": "function",
         "description": "Retrieves information about all frames of a given tab.",
         "async": "callback",
         "parameters": [
           {
             "type": "object",
             "name": "details",
             "description": "Information about the tab to retrieve all frames from.",
diff --git a/toolkit/modules/addons/WebNavigationContent.js b/toolkit/modules/addons/WebNavigationContent.js
--- a/toolkit/modules/addons/WebNavigationContent.js
+++ b/toolkit/modules/addons/WebNavigationContent.js
@@ -1,32 +1,25 @@
 "use strict";
 
 /* globals docShell */
 
 var Ci = Components.interfaces;
 
 Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
 
-function getWindowId(window) {
-  return window.QueryInterface(Ci.nsIInterfaceRequestor)
-               .getInterface(Ci.nsIDOMWindowUtils)
-               .outerWindowID;
-}
-
-function getParentWindowId(window) {
-  return getWindowId(window.parent);
-}
+XPCOMUtils.defineLazyModuleGetter(this, "WebNavigationFrames",
+                                  "resource://gre/modules/WebNavigationFrames.jsm");
 
 function loadListener(event) {
   let document = event.target;
   let window = document.defaultView;
   let url = document.documentURI;
-  let windowId = getWindowId(window);
-  let parentWindowId = getParentWindowId(window);
+  let windowId = WebNavigationFrames.getWindowId(window);
+  let parentWindowId = WebNavigationFrames.getParentWindowId(window);
   sendAsyncMessage("Extension:DOMContentLoaded", {windowId, parentWindowId, url});
 }
 
 addEventListener("DOMContentLoaded", loadListener);
 addMessageListener("Extension:DisableWebNavigation", () => {
   removeEventListener("DOMContentLoaded", loadListener);
 });
 
@@ -46,55 +39,58 @@ var WebProgressListener = {
                               .getInterface(Ci.nsIWebProgress);
     webProgress.removeProgressListener(this);
   },
 
   onStateChange: function onStateChange(webProgress, request, stateFlags, status) {
     let data = {
       requestURL: request.QueryInterface(Ci.nsIChannel).URI.spec,
       windowId: webProgress.DOMWindowID,
-      parentWindowId: getParentWindowId(webProgress.DOMWindow),
+      parentWindowId: WebNavigationFrames.getParentWindowId(webProgress.DOMWindow),
       status,
       stateFlags,
     };
     sendAsyncMessage("Extension:StateChange", data);
 
     if (webProgress.DOMWindow.top != webProgress.DOMWindow) {
       let webNav = webProgress.QueryInterface(Ci.nsIWebNavigation);
       if (!webNav.canGoBack) {
         // For some reason we don't fire onLocationChange for the
         // initial navigation of a sub-frame. So we need to simulate
         // it here.
         let data = {
           location: request.QueryInterface(Ci.nsIChannel).URI.spec,
           windowId: webProgress.DOMWindowID,
-          parentWindowId: getParentWindowId(webProgress.DOMWindow),
+          parentWindowId: WebNavigationFrames.getParentWindowId(webProgress.DOMWindow),
           flags: 0,
         };
         sendAsyncMessage("Extension:LocationChange", data);
       }
     }
   },
 
   onLocationChange: function onLocationChange(webProgress, request, locationURI, flags) {
     let data = {
       location: locationURI ? locationURI.spec : "",
       windowId: webProgress.DOMWindowID,
-      parentWindowId: getParentWindowId(webProgress.DOMWindow),
+      parentWindowId: WebNavigationFrames.getParentWindowId(webProgress.DOMWindow),
       flags,
     };
     sendAsyncMessage("Extension:LocationChange", data);
   },
 
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIWebProgressListener, Ci.nsISupportsWeakReference]),
 };
 
 var disabled = false;
 WebProgressListener.init();
 addEventListener("unload", () => {
   if (!disabled) {
+    disabled = true;
     WebProgressListener.uninit();
   }
 });
 addMessageListener("Extension:DisableWebNavigation", () => {
-  disabled = true;
-  WebProgressListener.uninit();
+  if (!disabled) {
+    disabled = true;
+    WebProgressListener.uninit();
+  }
 });
diff --git a/toolkit/modules/addons/WebNavigationFrames.jsm b/toolkit/modules/addons/WebNavigationFrames.jsm
new file mode 100644
--- /dev/null
+++ b/toolkit/modules/addons/WebNavigationFrames.jsm
@@ -0,0 +1,152 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const EXPORTED_SYMBOLS = ["WebNavigationFrames"];
+
+var Ci = Components.interfaces;
+
+/* exported WebNavigationFrames */
+
+function getWindowId(window) {
+  return window.QueryInterface(Ci.nsIInterfaceRequestor)
+               .getInterface(Ci.nsIDOMWindowUtils)
+               .outerWindowID;
+}
+
+function getParentWindowId(window) {
+  return getWindowId(window.parent);
+}
+
+/**
+ * Retrieve the DOMWindow associated to the docShell passed as parameter.
+ *
+ * @param    {nsIDocShell}  docShell - the docShell that we want to get the DOMWindow from.
+ * @return   {nsIDOMWindow}          - the DOMWindow associated to the docShell.
+ */
+function docShellToWindow(docShell) {
+  return docShell.QueryInterface(Ci.nsIInterfaceRequestor)
+    .getInterface(Ci.nsIDOMWindow);
+}
+
+/**
+ * The FrameDetail object which represents a frame in WebExtensions APIs.
+ *
+ * @typedef  {Object}  FrameDetail
+ * @inner
+ * @property {boolean} errorOccurred  - Indicates whether an error is occurred during the last load
+ *                                      happened on this frame.
+ * @property {number}  windowId       - Represents the numeric id which identify the frame in its tab.
+ * @property {number}  parentWindowId - Represents the numeric id which identify the parent frame.
+ * @property {string}  url            - Represents the current location URL loaded in the frame.
+ */
+
+/**
+ * Convert a DOMWindow object into its internal FrameDetail representation.
+ *
+ * @param    {nsIDOMWindow} window - the DOMWindow object to be converted into a FrameDetail JSON object.
+ * @return   {FrameDetail} the FrameDetail JSON object which represents the window.
+ */
+function convertWindowToFrameDetail(window) {
+  return {
+    windowId: getWindowId(window),
+    parentWindowId: getParentWindowId(window),
+    url: window.location.toString(),
+  };
+}
+
+// NOTE: Compute the Error Page loadType value. (See Bug 1190685 for rationale)
+// - LOAD_CMD_NORMAL (as defined in "docshell/base/nsIDocShell.idl"):
+// - LOAD_FLAGS_ERROR_PAGE (as defined in "docshell/base/nsDocShellLoadTypes.h")
+// - MAKE_LOAD_TYPE (as defined in "docshell/base/nsDocShellLoadTypes.h")
+// - LOAD_ERROR_PAGE (as defined in "docshell/base/nsDocShellLoadTypes.h")
+const LOAD_CMD_NORMAL = 0x1;
+const LOAD_FLAGS_ERROR_PAGE = 0x1;
+const MAKE_LOAD_TYPE = (type, flags) => (type | (flags << 16));
+const LOAD_ERROR_PAGE = MAKE_LOAD_TYPE(LOAD_CMD_NORMAL, LOAD_FLAGS_ERROR_PAGE);
+
+/**
+ * Convert a docShell object into its internal FrameDetail representation.
+ *
+ * @param    {nsIDocShell} docShell - the docShell object to be converted into a FrameDetail JSON object.
+ * @return   {FrameDetail} the FrameDetail JSON object which represents the docShell.
+ */
+function convertDocShellToFrameDetail(docShell) {
+  if (!docShell instanceof Ci.nsIDocShell) {
+    return null;
+  }
+  let window = docShellToWindow(docShell);
+
+  return Object.assign(convertWindowToFrameDetail(window), {
+    errorOccurred: (docShell.loadType == LOAD_ERROR_PAGE),
+  });
+}
+
+/**
+ * Search for a frame starting from the passed root docShell and
+ * convert it to its related frame detail representation.
+ *
+ * @param  {number}      windowId - the windowId of the frame to retrieve
+ * @param  {nsIDocShell} docShell - the root docShell object
+ * @return {FrameDetail} the FrameDetail JSON object which represents the docShell.
+ */
+function findFrame(windowId, docShell) {
+  let docShellsEnum = docShell.getDocShellEnumerator(
+    Ci.nsIDocShellTreeItem.typeAll,
+    Ci.nsIDocShell.ENUMERATE_FORWARDS
+  );
+
+  while (docShellsEnum.hasMoreElements()) {
+    let docShell = docShellsEnum.getNext();
+    let frameDetail = convertDocShellToFrameDetail(docShell);
+    if (frameDetail.windowId == windowId) {
+      return frameDetail;
+    }
+  }
+
+  return null;
+}
+
+/**
+ * Compute the array of all the frames' docShells which are descendants of root docShell
+ * passed as parameter.
+ * This helper function is used internally into this module to compute the result of the
+ * webNavigation's getAllFrames/getFrame API methods.
+ *
+ * @param    {nsIDocShell} docShell - the root docShell object
+ * @return   {nsIDocShell[]}        - the array of the frames' docShells collected
+ */
+function getChildDocShells(docShell) {
+  let docShellsEnum = docShell.getDocShellEnumerator(
+    Ci.nsIDocShellTreeItem.typeAll,
+    Ci.nsIDocShell.ENUMERATE_FORWARDS
+  );
+
+  let docShells = [];
+  while (docShellsEnum.hasMoreElements()) {
+    let docShell = docShellsEnum.getNext();
+    docShell.QueryInterface(Ci.nsIInterfaceRequestor)
+      .getInterface(Ci.nsIWebProgress);
+    docShells.push(docShell);
+  }
+  return docShells;
+}
+
+var WebNavigationFrames = {
+  getFrame(docShell, { frameId }) {
+    if (frameId == 0) {
+      return convertDocShellToFrameDetail(docShell);
+    }
+
+    return findFrame(frameId, docShell);
+  },
+
+  getAllFrames(docShell) {
+    return getChildDocShells(docShell).map(convertDocShellToFrameDetail);
+  },
+
+  getWindowId,
+  getParentWindowId,
+};
diff --git a/toolkit/modules/moz.build b/toolkit/modules/moz.build
--- a/toolkit/modules/moz.build
+++ b/toolkit/modules/moz.build
@@ -1,8 +1,9 @@
+
 # -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 XPCSHELL_TESTS_MANIFESTS += ['tests/xpcshell/xpcshell.ini']
 BROWSER_CHROME_MANIFESTS += ['tests/browser/browser.ini']
@@ -14,16 +15,17 @@ TESTING_JS_MODULES += [
 ]
 
 SPHINX_TREES['toolkit_modules'] = 'docs'
 
 EXTRA_JS_MODULES += [
     'addons/MatchPattern.jsm',
     'addons/WebNavigation.jsm',
     'addons/WebNavigationContent.js',
+    'addons/WebNavigationFrames.jsm',
     'addons/WebRequest.jsm',
     'addons/WebRequestCommon.jsm',
     'addons/WebRequestContent.js',
     'Battery.jsm',
     'BinarySearch.jsm',
     'BrowserUtils.jsm',
     'CertUtils.jsm',
     'CharsetMenu.jsm',
