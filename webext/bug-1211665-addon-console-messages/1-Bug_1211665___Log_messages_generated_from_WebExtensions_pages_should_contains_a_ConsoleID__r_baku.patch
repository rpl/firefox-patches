# HG changeset patch
# User Luca Greco <luca.greco@alcacoop.it>
# Date 1458838206 -3600
#      Thu Mar 24 17:50:06 2016 +0100
# Node ID 004033690c4ad972b28c4d08872603d1f63a0496
# Parent  3dc5292ed66afbca801c33bff49c86154b3b3c24
Bug 1211665 - Log messages generated from WebExtensions pages should contains a ConsoleID. r?baku

- get the addonId from the Principal origin attributes, if any
- tag addon Console API messages with a custom consoleID ("addon/ID"),
  which is how the Addon Console RDP Actor recognize the messages that have to be
  collected and shown in the Addon Console Panel

MozReview-Commit-ID: 5v9BWLbgskd

diff --git a/dom/base/Console.cpp b/dom/base/Console.cpp
--- a/dom/base/Console.cpp
+++ b/dom/base/Console.cpp
@@ -135,16 +135,22 @@ public:
     MOZ_ASSERT(mIDType == eUnknown);
 
     mOuterIDString = aOuterID;
     mInnerIDString = aInnerID;
     mIDType = eString;
   }
 
   void
+  SetOriginAttributes(const JS::Value& aOriginAttributes)
+  {
+    mOriginAttributes = aOriginAttributes;
+  }
+
+  void
   CleanupJSObjects()
   {
     AssertIsOnOwningThread();
     mCopiedArguments.Clear();
 
     if (mConsole) {
       mConsole->UnregisterConsoleCallData(this);
       mConsole = nullptr;
@@ -219,16 +225,18 @@ public:
   } mIDType;
 
   uint64_t mOuterIDNumber;
   nsString mOuterIDString;
 
   uint64_t mInnerIDNumber;
   nsString mInnerIDString;
 
+  JS::Value mOriginAttributes;
+
   nsString mMethodString;
 
   // Stack management is complicated, because we want to do it as
   // lazily as possible.  Therefore, we have the following behavior:
   // 1)  mTopStackFrame is initialized whenever we have any JS on the stack
   // 2)  mReifiedStack is initialized if we're created in a worker.
   // 3)  mStack is set (possibly to null if there is no JS on the stack) if
   //     we're created on main thread.
@@ -549,38 +557,58 @@ private:
   RunConsole(JSContext* aCx, nsPIDOMWindowOuter* aOuterWindow,
              nsPIDOMWindowInner* aInnerWindow) override
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(mCallData->mCopiedArguments.IsEmpty());
 
     // The windows have to run in parallel.
     MOZ_ASSERT(!!aOuterWindow == !!aInnerWindow);
+    nsIPrincipal* principal;
+    JS::RootedValue mOriginAttributes(aCx);
 
     if (aOuterWindow) {
+      // Customize the consoleID if the script object principal has
+      // an addonId.
+      nsCOMPtr<nsIScriptObjectPrincipal> sop = do_QueryInterface(aInnerWindow);
+      if (sop) {
+        principal = sop->GetPrincipal();
+        if (principal) {
+          BasePrincipal::Cast(principal)->GetOriginAttributes(aCx, &mOriginAttributes);
+          mCallData->SetOriginAttributes(mOriginAttributes);
+        }
+      }
+
       mCallData->SetIDs(aOuterWindow->WindowID(), aInnerWindow->WindowID());
     } else {
       ConsoleStackEntry frame;
       if (mCallData->mTopStackFrame) {
         frame = *mCallData->mTopStackFrame;
       }
 
       nsString id = frame.mFilename;
       nsString innerID;
+
       if (mWorkerPrivate->IsSharedWorker()) {
         innerID = NS_LITERAL_STRING("SharedWorker");
       } else if (mWorkerPrivate->IsServiceWorker()) {
         innerID = NS_LITERAL_STRING("ServiceWorker");
         // Use scope as ID so the webconsole can decide if the message should
         // show up per tab
         id.AssignWithConversion(mWorkerPrivate->WorkerName());
       } else {
         innerID = NS_LITERAL_STRING("Worker");
       }
 
+      principal = mWorkerPrivate->GetPrincipal();
+      if (principal) {
+        BasePrincipal::Cast(principal)->GetOriginAttributes(aCx, &mOriginAttributes);
+        mCallData->SetOriginAttributes(mOriginAttributes);
+      }
+
       mCallData->SetIDs(id, innerID);
     }
 
     // Now we could have the correct window (if we are not window-less).
     mClonedData.mParent = aInnerWindow;
 
     ProcessCallData(aCx);
 
@@ -1259,16 +1287,30 @@ Console::Method(JSContext* aCx, MethodNa
 
     callData->mCountValue = IncreaseCounter(aCx, frame, aData,
                                             callData->mCountLabel);
   }
 
   JS::Rooted<JSObject*> global(aCx, JS::CurrentGlobalOrNull(aCx));
 
   if (NS_IsMainThread()) {
+    if (mWindow) {
+      nsCOMPtr<nsIScriptObjectPrincipal> sop = do_QueryInterface(mWindow);
+      if (sop) {
+        nsIPrincipal* principal = sop->GetPrincipal();
+
+        if (principal) {
+          JS::RootedValue mOriginAttributes(aCx);
+          BasePrincipal::Cast(principal)->GetOriginAttributes(aCx, &mOriginAttributes);
+
+          callData->SetOriginAttributes(mOriginAttributes);
+        }
+      }
+    }
+
     callData->SetIDs(mOuterID, mInnerID);
     ProcessCallData(callData, global, aData);
     return;
   }
 
   RefPtr<ConsoleCallDataRunnable> runnable =
     new ConsoleCallDataRunnable(this, callData);
   runnable->Dispatch(global);
@@ -1370,16 +1412,18 @@ Console::ProcessCallData(ConsoleCallData
   }
 
   event.mLineNumber = frame.mLineNumber;
   event.mColumnNumber = frame.mColumnNumber;
   event.mFunctionName = frame.mFunctionName;
   event.mTimeStamp = aData->mTimeStamp;
   event.mPrivate = aData->mPrivate;
 
+  event.mOriginAttributes = aData->mOriginAttributes;
+
   switch (aData->mMethodName) {
     case MethodLog:
     case MethodInfo:
     case MethodWarn:
     case MethodError:
     case MethodException:
     case MethodDebug:
     case MethodAssert:
diff --git a/dom/base/Console.h b/dom/base/Console.h
--- a/dom/base/Console.h
+++ b/dom/base/Console.h
@@ -305,16 +305,17 @@ private:
   nsTArray<ConsoleCallData*> mConsoleCallDataArray;
 
 #ifdef DEBUG
   PRThread* mOwningThread;
 #endif
 
   uint64_t mOuterID;
   uint64_t mInnerID;
+  JS::Value mOriginAttributes;
 
   friend class ConsoleCallData;
   friend class ConsoleRunnable;
   friend class ConsoleCallDataRunnable;
   friend class ConsoleProfileRunnable;
 };
 
 } // namespace dom
diff --git a/dom/tests/browser/browser.ini b/dom/tests/browser/browser.ini
--- a/dom/tests/browser/browser.ini
+++ b/dom/tests/browser/browser.ini
@@ -12,16 +12,17 @@ support-files =
 support-files =
   test_new_window_from_content_child.html
 [browser_bug1008941_dismissGeolocationHanger.js]
 skip-if = buildapp == 'mulet'
 [browser_test__content.js]
 skip-if = e10s
 [browser_ConsoleAPITests.js]
 skip-if = e10s
+[browser_ConsoleAPI_ConsoleID.js]
 [browser_ConsoleStorageAPITests.js]
 skip-if = e10s
 [browser_ConsoleStoragePBTest_perwindowpb.js]
 skip-if = e10s
 [browser_autofocus_background.js]
 skip-if= buildapp == 'mulet'
 [browser_autofocus_preference.js]
 [browser_bug1238427.js]
diff --git a/dom/tests/browser/browser_ConsoleAPI_ConsoleID.js b/dom/tests/browser/browser_ConsoleAPI_ConsoleID.js
new file mode 100644
--- /dev/null
+++ b/dom/tests/browser/browser_ConsoleAPI_ConsoleID.js
@@ -0,0 +1,76 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+const ConsoleAPIStorage = Cc["@mozilla.org/consoleAPI-storage;1"]
+      .getService(Ci.nsIConsoleAPIStorage);
+
+const FAKE_ADDON_ID = "test-webext-addon@mozilla.org";
+const EXPECTED_CONSOLE_ID = `addon/${FAKE_ADDON_ID}`;
+const EXPECTED_CONSOLE_MESSAGE_CONTENT = "fake-webext-addon-test-log-message";
+const ConsoleObserver = {
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
+
+  init() {
+    Services.obs.addObserver(this, "console-api-log-event", false);
+  },
+
+  uninit() {
+    Services.obs.removeObserver(this, "console-api-log-event", false);
+  },
+
+  observe(aSubject, aTopic, aData) {
+    if (aTopic == "console-api-log-event") {
+      let consoleAPIMessage = aSubject.wrappedJSObject;
+
+      is(consoleAPIMessage.arguments[0], EXPECTED_CONSOLE_MESSAGE_CONTENT,
+         "the consoleAPIMessage contains the expected message");
+
+      ok(consoleAPIMessage.originAttributes, "the consoleAPImessage contains originattributes");
+      is(consoleAPIMessage.originAttributes.addonId, FAKE_ADDON_ID,
+         "the consoleAPImessage's originAttributes contains the expected addonId");
+
+      let cachedMessages = ConsoleAPIStorage.getEvents();
+
+      is(cachedMessages.length, 1, "found one console api messsage as expected");
+
+      ok(cachedMessages[0].originAttributes, "the consoleAPImessage contains originattributes");
+      is(cachedMessages[0].originAttributes.addonId, FAKE_ADDON_ID,
+         "the consoleAPImessage's originAttributes contains the expected addonId");
+
+      finish();
+    }
+  }
+};
+
+function test()
+{
+  ConsoleObserver.init();
+
+  waitForExplicitFinish();
+
+  let uuidGenerator = Cc["@mozilla.org/uuid-generator;1"].getService(Ci.nsIUUIDGenerator);
+  let uuid = uuidGenerator.generateUUID().number;
+  uuid = uuid.slice(1, -1); // Strip { and } off the UUID.
+  let baseURI = Services.io.newURI("about:blank", null, null);
+  let originAttributes = {addonId: FAKE_ADDON_ID};
+  let principal = Services.scriptSecurityManager
+        .createCodebasePrincipal(baseURI, originAttributes);
+
+  let chromeWebNav = Services.appShell.createWindowlessBrowser(true);
+  let interfaceRequestor = chromeWebNav.QueryInterface(Ci.nsIInterfaceRequestor);
+  let docShell = interfaceRequestor.getInterface(Ci.nsIDocShell);
+  docShell.createAboutBlankContentViewer(principal);
+
+  info("fake webextension docShell created");
+
+  registerCleanupFunction(function() {
+    ConsoleObserver.uninit();
+    chromeWebNav.close();
+    chromeWebNav = null;
+  });
+
+  let window = docShell.contentViewer.DOMDocument.defaultView;
+  window.location = `javascript:console.log("${EXPECTED_CONSOLE_MESSAGE_CONTENT}");`;
+
+  info("fake webextension page logged a console api message");
+}
diff --git a/dom/webidl/Console.webidl b/dom/webidl/Console.webidl
--- a/dom/webidl/Console.webidl
+++ b/dom/webidl/Console.webidl
@@ -40,16 +40,17 @@ interface Console {
   [BinaryName="noopMethod"]
   void timelineEnd();
 };
 
 // This is used to propagate console events to the observers.
 dictionary ConsoleEvent {
   (unsigned long long or DOMString) ID;
   (unsigned long long or DOMString) innerID;
+  any originAttributes = null;
   DOMString level = "";
   DOMString filename = "";
   unsigned long lineNumber = 0;
   unsigned long columnNumber = 0;
   DOMString functionName = "";
   double timeStamp = 0;
   sequence<any> arguments;
   sequence<DOMString?> styles;
