# HG changeset patch
# User Luca Greco <lgreco@mozilla.com>
# Date 1462277591 -7200
#      Tue May 03 14:13:11 2016 +0200
# Node ID d8379d17070aca105575eb3364a7388850c02277
# Parent  3139e676e6625ff35af6fca0057220e804517313
TMP: replace SDK weak-set with direct weak reference tracking.

MozReview-Commit-ID: HhP8X53i6z7

diff --git a/addon-sdk/source/lib/sdk/core/disposable.js b/addon-sdk/source/lib/sdk/core/disposable.js
--- a/addon-sdk/source/lib/sdk/core/disposable.js
+++ b/addon-sdk/source/lib/sdk/core/disposable.js
@@ -3,16 +3,18 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 module.metadata = {
   "stability": "experimental"
 };
 
+const { Cu, Ci } = require("chrome");
+
 const { Class } = require("./heritage");
 const method = require("../../method/core");
 
 const unloadSubject = require('@loader/unload');
 const addonUnloadTopic = "sdk:loader:destroy";
 
 const { on } = require('../system/events');
 
@@ -38,63 +40,64 @@ const dispose = method("disposable/dispo
 exports.dispose = dispose;
 dispose.define(Object, object => object.dispose());
 
 const setup = method("disposable/setup");
 exports.setup = setup;
 setup.define(Object, (object, ...args) => object.setup(...args));
 
 const { isWeak } = require("./reference");
-const WeakSet = require("../lang/weak-set");
 
-const weakDisposables = {};
+const disposablesWeakRefs = new WeakMap();
 const disposables = new Set();
 
 on(addonUnloadTopic, ({ subject }) => {
   if (subject.wrappedJSObject !== unloadSubject) {
     return;
   }
 
   function tryDisposableUnload(disposable) {
+    let realDisposable = disposable instanceof Ci.xpcIJSWeakReference ?
+          disposable.get() : disposable;
+
     try {
-      if (disposable) {
-        unload(disposable);
+      if (realDisposable) {
+        unload(realDisposable);
       }
     } catch(e) {
-      console.error("Error unloading a disposable", e);
+      console.error("Error unloading a disposable", realDisposable, e);
     }
   }
 
   for (let disposable of disposables) {
     tryDisposableUnload(disposable);
   }
 
   disposables.clear();
-
-  for (let disposable of WeakSet.iterator(weakDisposables)) {
-    tryDisposableUnload(disposable);
-  }
-
-  WeakSet.clear(weakDisposables);
 });
 
 // Set's up disposable instance.
 const setupDisposable = disposable => {
-  if (isWeak(disposable)) {
-    WeakSet.add(weakDisposables, disposable);
+  if (isWeak(disposable) && !disposablesWeakRefs.has(disposable)) {
+    // If is a weak reference and is not already tracked.
+    let weakRef = Cu.getWeakReference(disposable);
+    disposablesWeakRefs.set(disposable, weakRef);
+    disposables.add(weakRef);
   } else {
     disposables.add(disposable);
   }
 };
 exports.setupDisposable = setupDisposable;
 
 // Tears down disposable instance.
 const disposeDisposable = disposable => {
   if (isWeak(disposable)) {
-    WeakSet.remove(weakDisposables, disposable);
+    let weakRef = disposablesWeakRefs.get(disposable);
+    disposables.delete(weakRef);
+    disposablesWeakRefs.delete(disposable);
   } else {
     disposables.delete(disposable);
   }
 };
 exports.disposeDisposable = disposeDisposable;
 
 // Base type that takes care of disposing it's instances on add-on unload.
 // Also makes sure to remove unload listener if it's already being disposed.
