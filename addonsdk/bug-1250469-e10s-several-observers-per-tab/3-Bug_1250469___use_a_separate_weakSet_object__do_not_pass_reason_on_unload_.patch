# HG changeset patch
# User Luca Greco <lgreco@mozilla.com>
# Date 1457847255 -3600
#      Sun Mar 13 06:34:15 2016 +0100
# Node ID ecc32c0415ee5e267e094041b51bb1672a5b17e3
# Parent  72f22fc2cf25ef5e9bd2f1e3d76246eeba08fd99
Bug 1250469 - use a separate weakSet object, do not pass reason on unload.

diff --git a/addon-sdk/source/lib/sdk/core/disposable.js b/addon-sdk/source/lib/sdk/core/disposable.js
--- a/addon-sdk/source/lib/sdk/core/disposable.js
+++ b/addon-sdk/source/lib/sdk/core/disposable.js
@@ -39,60 +39,62 @@ exports.dispose = dispose;
 dispose.define(Object, object => object.dispose());
 
 const setup = method("disposable/setup");
 exports.setup = setup;
 setup.define(Object, (object, ...args) => object.setup(...args));
 
 const { isWeak } = require("./reference");
 const WeakSet = require("../lang/weak-set");
+
+const weakDisposables = {};
 const disposables = new Set();
 
-on(addonUnloadTopic, ({ subject, data }) => {
+on(addonUnloadTopic, ({ subject }) => {
   if (subject.wrappedJSObject !== unloadSubject) {
     return;
   }
 
   function tryDisposableUnload(disposable) {
     try {
       if (disposable) {
-        unload(disposable, data);
+        unload(disposable);
       }
     } catch(e) {
       console.error("Error unloading a disposable", e);
     }
   }
 
   for (let disposable of disposables) {
     tryDisposableUnload(disposable);
   }
 
   disposables.clear();
 
-  for (let disposable of WeakSet.iterator(disposables)) {
+  for (let disposable of WeakSet.iterator(weakDisposables)) {
     tryDisposableUnload(disposable);
   }
 
-  WeakSet.clear(disposables);
+  WeakSet.clear(weakDisposables);
 });
 
 // Set's up disposable instance.
 const setupDisposable = disposable => {
   if (isWeak(disposable)) {
-    WeakSet.add(disposables, disposable);
+    WeakSet.add(weakDisposables, disposable);
   } else {
     disposables.add(disposable);
   }
 };
 exports.setupDisposable = setupDisposable;
 
 // Tears down disposable instance.
 const disposeDisposable = disposable => {
   if (isWeak(disposable)) {
-    WeakSet.remove(disposables, disposable);
+    WeakSet.remove(weakDisposables, disposable);
   } else {
     disposables.delete(disposable);
   }
 };
 exports.disposeDisposable = disposeDisposable;
 
 // Base type that takes care of disposing it's instances on add-on unload.
 // Also makes sure to remove unload listener if it's already being disposed.
@@ -131,23 +133,25 @@ const unloaders = {
 const unloaded = new WeakMap();
 unload.define(Disposable, (disposable, reason) => {
   if (!unloaded.get(disposable)) {
     unloaded.set(disposable, true);
     // Pick an unload handler associated with an unload
     // reason (falling back to destroy if not found) and
     // delegate unloading to it.
     const unload = unloaders[reason] || unloaders.destroy;
-    unload(disposable, reason);
+    unload(disposable);
   }
 });
 
 // If add-on is disabled manually, it's being upgraded, downgraded
 // or uninstalled `dispose` is invoked to undo any changes that
 // has being done by it in this session.
 disable.define(Disposable, dispose);
 downgrade.define(Disposable, dispose);
 upgrade.define(Disposable, dispose);
 uninstall.define(Disposable, dispose);
 
-// If the shutdown `dispose` is not defined some of the test cases
-// will fail if the loader is unloading with 'shutdown' reason.
-shutdown.define(Disposable, dispose);
+// If application is shut down no dispose is invoked as undo-ing
+// changes made by instance is likely to just waste of resources &
+// increase shutdown time. Although specefic components may choose
+// to implement shutdown handler that does something better.
+shutdown.define(Disposable, disposable => {});
diff --git a/addon-sdk/source/test/test-disposable.js b/addon-sdk/source/test/test-disposable.js
--- a/addon-sdk/source/test/test-disposable.js
+++ b/addon-sdk/source/test/test-disposable.js
@@ -61,20 +61,20 @@ exports["test destroy reasons"] = assert
   f2.destroy("uninstall")
   f2.destroy();
   assert.equal(disposals, 1, "disposal happens just once");
 
   disposals = 0;
   const f3 = new Foo();
 
   f3.destroy("shutdown");
-  assert.equal(disposals, 1, "shutdown invoke disposal");
+  assert.equal(disposals, 0, "shutdown invoke disposal");
   f3.destroy("shutdown");
   f3.destroy();
-  assert.equal(disposals, 1, "shutdown disposal happens just once");
+  assert.equal(disposals, 0, "shutdown disposal happens just once");
 
   disposals = 0;
   const f4 = new Foo();
 
   f4.destroy("disable");
   assert.equal(disposals, 1, "disable invokes disposal");
   f4.destroy("disable")
   f4.destroy();
