# HG changeset patch
# User Luca Greco <luca.greco@alcacoop.it>

Bug 1211859 - add open extension devtools API and devtools_page and devtools_panel extension pages

---
 browser/components/extensions/ext-devtools.js      | 315 +++++++++++++++++++++
 browser/components/extensions/jar.mn               |   1 +
 .../components/extensions/test/browser/browser.ini |   1 +
 .../test/browser/browser_ext_devtools_page.js      |  98 +++++++
 browser/components/extensions/test/browser/head.js |   5 +
 browser/components/nsBrowserGlue.js                |   9 +-
 devtools/server/actors/webconsole.js               |  33 ++-
 devtools/shared/webconsole/client.js               |   3 +
 8 files changed, 454 insertions(+), 11 deletions(-)
 create mode 100644 browser/components/extensions/ext-devtools.js
 create mode 100644 browser/components/extensions/test/browser/browser_ext_devtools_page.js

diff --git a/browser/components/extensions/ext-devtools.js b/browser/components/extensions/ext-devtools.js
new file mode 100644
index 0000000..021addc
--- /dev/null
+++ b/browser/components/extensions/ext-devtools.js
@@ -0,0 +1,315 @@
+Cu.import("resource://gre/modules/ExtensionUtils.jsm");
+var {
+  EventManager,
+  ignoreEvent,
+  runSafe,
+  runSafeWithoutClone,
+} = ExtensionUtils;
+
+let { gDevTools } = Cu.import("resource:///modules/devtools/client/framework/gDevTools.jsm", {});
+
+// Map[extension -> devtools_page]
+let devtoolsPageMap = new Map();
+
+extensions.on("manifest_devtools_page", (type, directive, extension, manifest) => {
+  let devtoolsPage = new DevtoolsPage(manifest[directive], extension);
+  devtoolsPageMap.set(extension, devtoolsPage);
+});
+
+class DevtoolsPage {
+  constructor(url, extension) {
+    this.url = url;
+    this.extension = extension;
+
+    // Map[target -> ExtensionPage]
+    this.targetContextMap = new Map();
+
+    // Set[DevtoolsPanel]
+    this.devtoolsPanelSet = new Set();
+  }
+
+  shutdown() {
+    // TODO: destroy method
+    // - destroy devtools page toolbox contexts
+    // - destroy devtools panels
+    for (let panel of this.devtoolsPanelSet) {
+      panel.shutdown();
+    }
+    this.devtoolsPanelSet.clear();
+
+    for (let target of this.targetContextMap.keys()) {
+      this.shutdownForTarget(target);
+    }
+    this.targetContextMap.clear();
+  }
+
+  trackDevtoolsPanel(panel) {
+    this.devtoolsPanelSet.add(panel);
+  }
+
+  buildForToolbox(toolbox) {
+    if (this.targetContextMap.has(toolbox.target)) {
+      return;
+    }
+    let webNav = Services.appShell.createWindowlessBrowser(false);
+
+    let principal = Services.scriptSecurityManager.createCodebasePrincipal(this.extension.baseURI, {addonId: this.extension.id});
+
+    let interfaceRequestor = webNav.QueryInterface(Ci.nsIInterfaceRequestor);
+    let docShell = interfaceRequestor.getInterface(Ci.nsIDocShell);
+
+    let context = new ExtensionPage(this.extension, {type: "devtools_page", docShell});
+    context.toolbox = toolbox;
+    GlobalManager.injectInDocShell(docShell, this.extension, context);
+
+    docShell.createAboutBlankContentViewer(principal);
+
+    let window = webNav.document.defaultView;
+    context.contentWindow = window;
+    context.webNav = webNav;
+    context.docShell = docShell;
+
+    let url;
+    url = this.extension.baseURI.resolve(this.url);
+    webNav.loadURI(url, 0, null, null, null);
+
+    this.targetContextMap.set(toolbox.target, context);
+  }
+
+  shutdownForTarget(target) {
+    let context = this.targetContextMap.get(target);
+    if (context && context.webNav) {
+      context.webNav.loadURI("about:blank", 0, null, null, null);
+      context.webNav = null;
+    }
+  }
+}
+
+gDevTools.on("toolbox-ready", (evt, toolbox) => {
+  for (let entry of devtoolsPageMap.entries()) {
+    let [extension, devtoolsPage] = entry;
+    devtoolsPage.buildForToolbox(toolbox);
+  }
+});
+
+gDevTools.on("toolbox-destroyed", (evt, target) => {
+  for (let entry of devtoolsPageMap.entries()) {
+    let [extension, devtoolsPage] = entry;
+
+    devtoolsPage.shutdownForTarget(target);
+  }
+});
+
+function makeWidgetId(id)
+{
+  id = id.toLowerCase();
+  return id.replace(/[^a-z0-9_-]/g, "_");
+}
+
+function makeDevtoolsPanelId(id, url)
+{
+  return `${makeWidgetId(id)}-${url}-devtools-panel`;
+}
+
+class DevtoolsPanel {
+  constructor(extension, context, title, icon, url, callback) {
+    this.url = url;
+    this.parentContext = context;
+    this.extension = extension;
+
+    devtoolsPageMap.get(extension).trackDevtoolsPanel(this);
+
+    // Map[toolbox -> ExtensionPage]
+    this.toolboxContextMap = new Map();
+
+    let panelId = this.id = makeDevtoolsPanelId(extension.id, url);
+    let definition = gDevTools.getToolDefinition(panelId);
+
+    if (!definition) {
+      gDevTools.registerTool({
+        id: panelId,
+        url: "about:blank",
+        icon: icon ? this.extension.baseURI.resolve(icon) : null,
+        label: title,
+        invertIconForLightTheme: true,
+        isTargetSupported: target => target.isLocalTab,
+        build: (window, toolbox) => {
+          let context = this.buildForToolbox(window, toolbox);
+
+          return {
+            toolbox,
+            destroy() {
+              context.browser.setAttribute("src", "about:blank");
+              context.browser = null;
+              context.unload();
+            }
+          };
+        }
+      })
+    }
+  }
+
+  shutdown() {
+    for (let context of this.toolboxContextMap.values()) {
+      context.unload();
+    }
+    this.toolboxContextMap.clear();
+
+    if (gDevTools.getToolDefinition(this.id)) {
+      gDevTools.unregisterTool(this.id);
+    }
+  }
+
+  buildForToolbox(window, toolbox) {
+    let { document } = window;
+    const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+    let browser = document.createElementNS(XUL_NS, "browser");
+    browser.setAttribute("type", "content");
+    browser.setAttribute("disableglobalhistory", "true");
+    browser.setAttribute("style", "width: 100%; height: 100%;");
+    document.body.setAttribute("style", "margin: 0; padding: 0;")
+    document.body.appendChild(browser);
+
+    let url = this.extension.baseURI.resolve(this.url);
+
+    let context = new ExtensionPage(this.extension, {
+      type: "devtools_panel",
+      contentWindow: browser.contentWindow,
+      uri: Services.io.newURI(url, null, null),
+      docShell: browser.docShell,
+    });
+    context.toolbox = toolbox;
+    context.browser = browser;
+
+    this.toolboxContextMap.set(toolbox, context);
+
+    GlobalManager.injectInDocShell(browser.docShell, this.extension, context);
+    browser.setAttribute("src", url);
+
+    return context;
+  }
+}
+
+extensions.registerAPI((extension, context) => {
+  // filter or any extension page besides devtools_page and devtools_panel types
+  if (["devtools_page", "devtools_panel"].indexOf(context.type) < 0) {
+    return;
+  }
+
+  let { toolbox } = context;
+
+  // filter out any page without a valid toolbox or target
+  // TODO: raise an exception? what about "about:blank" used to unload the
+  // devtools page?
+  if (!toolbox || !toolbox.target) {
+    return;
+  }
+
+  let { target } = toolbox;
+
+  let windowId, tabId;
+
+  if (target.isLocalTab) {
+    let browser = target.tab.linkedBrowser;
+    let parentWindow = browser.ownerDocument.defaultView;
+    windowId = WindowManager.getId(parentWindow);
+
+    let tab = parentWindow.gBrowser.getTabForBrowser(browser);
+    tabId = TabManager.getId(tab);
+
+    context.windowId = windowId;
+    context.tabId = tabId;
+  } else {
+    // TODO: windowID and tabId for remote tabs needs to get tab manager info
+    // from the TabManager on the remote side
+  }
+
+  // devtools API
+  let devtools = {
+    inspectedWindow: {
+      windowId,
+      tabId,
+      getResources() {
+        // TODO: incomplete, currently it is just a shim
+        return [ { type: "document", url: target.url } ];
+      },
+      eval(text, options = {}, cb) {
+        if (typeof options == "function") {
+          cb = options;
+          options = {};
+        }
+
+        // TODO: add support to eval options
+        // NOTE: support for evaluating into frames can use bindObjectActor?
+
+        // raise exception on unsupported options
+        for (k of ["frameURL", "useContentScriptContext", "contextSecurityOrigin"]) {
+          if (k == "frameURL" && options[k] === target.url) {
+            // tollerate unsupported frameURL if equal to the target url
+            continue;
+          }
+
+          if (options[k]) {
+            throw context.contentWindow.Error(`Unsupported option ${k}: ${options[k]}`);
+          }
+        }
+
+        // TODO: cb should receive exceptionInfo
+        target.activeConsole.evaluateJSAsync(text, (res) => {
+          if (res.error) {
+            runSafe(context, cb, res.error, true);
+          } else {
+            // TODO: check typeof result is string or dump error
+            runSafe(context, cb, res.plainResult, false);
+          }
+        }, {
+          unsafeDereference: true
+        });
+      },
+      reload(options = {}) {
+        // TODO: add support for custom userAgent, log deprecated on preprocessorScript
+
+        // raise exception on unsupported options
+        for (k of ["userAgent", "preprocessorScript"]) {
+          if (options[k]) {
+            throw context.contentWindow.Error(`Unsupported ${k} option`);
+          }
+        }
+
+        let { injectedScript, ignoreCache } = options;
+
+        target.activeConsole.evaluateJSAsync(injectedScript, _ => {}, {
+          runOnNextWindowReady: true
+        });
+
+        target.activeTab.reload({ force: ignoreCache });
+      }
+    },
+    panels: {
+      elements: {
+        createSidebarPane() {}
+      },
+      create(title, icon, url, cb) {
+        let tool = new DevtoolsPanel(extension, context, title, icon, url);
+
+        let waitReady = (evt, panel) => {
+          if (typeof cb == "function") {
+            // TODO: should return a panel object
+            runSafe(context, cb, {});
+          }
+        }
+
+        toolbox.once(`${tool.id}-ready`, waitReady);
+      }
+    }
+  };
+
+  return { devtools };
+});
+
+extensions.on("shutdown", (type, extension) => {
+  if (devtoolsPageMap.has(extension)) {
+    devtoolsPageMap.get(extension).shutdown();
+    devtoolsPageMap.delete(extension);
+  }
+});
diff --git a/browser/components/extensions/jar.mn b/browser/components/extensions/jar.mn
index 07b6af3..6f75974 100644
--- a/browser/components/extensions/jar.mn
+++ b/browser/components/extensions/jar.mn
@@ -4,8 +4,9 @@
 
 browser.jar:
     content/browser/extension.svg
     content/browser/ext-utils.js
     content/browser/ext-contextMenus.js
     content/browser/ext-browserAction.js
     content/browser/ext-tabs.js
     content/browser/ext-windows.js
+    content/browser/ext-devtools.js
diff --git a/browser/components/extensions/test/browser/browser.ini b/browser/components/extensions/test/browser/browser.ini
index 6012a80..6b0015a 100644
--- a/browser/components/extensions/test/browser/browser.ini
+++ b/browser/components/extensions/test/browser/browser.ini
@@ -11,8 +11,9 @@ support-files =
 [browser_ext_contextMenus.js]
 [browser_ext_getViews.js]
 [browser_ext_tabs_executeScript.js]
 [browser_ext_tabs_query.js]
 [browser_ext_tabs_update.js]
 [browser_ext_windows_update.js]
 [browser_ext_contentscript_connect.js]
 [browser_ext_tab_runtimeConnect.js]
+[browser_ext_devtools_page.js]
diff --git a/browser/components/extensions/test/browser/browser_ext_devtools_page.js b/browser/components/extensions/test/browser/browser_ext_devtools_page.js
new file mode 100644
index 0000000..86f6fac
--- /dev/null
+++ b/browser/components/extensions/test/browser/browser_ext_devtools_page.js
@@ -0,0 +1,98 @@
+add_task(function* test_devtools() {
+  let { gDevTools } = Cu.import("resource:///modules/devtools/client/framework/gDevTools.jsm", {});
+  let { devtools } = Cu.import("resource://gre/modules/devtools/shared/Loader.jsm", {});
+
+  let extension = ExtensionTestUtils.loadExtension({
+    manifest: {
+      devtools_page: "devtools_page.html",
+    },
+    files: {
+      'devtools_page.html': `
+        <!DOCTYPE html>
+        <html>
+          <head>
+            <meta charset="utf-8">
+            <title>Devtools Page</title>
+            <script src="devtools_page.js"></script>
+          </head>
+          <body>
+
+          </body>
+        </html>
+      `,
+      'devtools_page.js': function() {
+        browser.test.sendMessage("devtools_page.loaded");
+
+        browser.test.assertTrue(browser.devtools, "browser.devtools api found");
+        browser.test.assertTrue(browser.devtools.panels, "browser.devtools.panels api found");
+        browser.test.assertTrue(browser.devtools.inspectedWindow, "browser.devtools.inspectedWindow api found");
+
+        browser.devtools.panels.create("test-panel", "icon.png", "devtools_panel.html", function(panel) {
+          browser.test.sendMessage("devtools_page.panels_create_callback")
+        });
+        browser.test.sendMessage("devtools_page.panels_create_called")
+      },
+      'devtools_panel.html': `
+        <!DOCTYPE html>
+        <html>
+          <head>
+            <meta charset="utf-8">
+          </head>
+          <body>
+            <h1>DEVTOOLSPANEL</h1>
+            <script>
+              browser.test.sendMessage("devtools_panel.loaded");
+
+              browser.test.assertTrue(browser.devtools, "browser.devtools api found");
+              browser.test.assertTrue(browser.devtools.inspectedWindow, "browser.devtools.inspectedWindow api found");
+              browser.test.assertTrue(browser.devtools.inspectedWindow.eval, "browser.devtools.inspectedWindow.eval api found");
+
+              browser.devtools.inspectedWindow.eval("({ test_key: 'test_value'})", (res, isException) => {
+                browser.test.sendMessage("devtools_panel.inspectedWindow_eval_callback")
+
+                browser.test.assertTrue(!isException, "inspectedWindow's isException should be false");
+                browser.test.assertEq("test_value", res.test_key, "inspectedWindow's result should contains the expected data");
+              });
+              browser.test.sendMessage("devtools_panel.inspectedWindow_eval_called")
+            </script>
+          </body>
+        </html>
+      `
+    }
+  });
+  info("load complete");
+  yield extension.startup();
+
+  let tab = yield BrowserTestUtils.openNewForegroundTab(gBrowser, "http://mochi.test:8888/");
+  let target = devtools.TargetFactory.forTab(tab);
+
+  //Services.prefs.setCharPref("webextension.devtools.evalType", "RDP");
+
+  yield gDevTools.showToolbox(target, 'webconsole');
+  info("developer toolbox opened")
+
+  yield Promise.all([
+    extension.awaitMessage("devtools_page.loaded"),
+    extension.awaitMessage("devtools_page.panels_create_called"),
+  ]);
+
+  info("devtools_page created and loaded")
+
+  yield gDevTools.showToolbox(target, makeDevtoolsPanelId(extension.id, "devtools_panel.html"));
+
+  yield Promise.all([
+    extension.awaitMessage("devtools_panel.loaded"),
+    extension.awaitMessage("devtools_panel.inspectedWindow_eval_called"),
+    extension.awaitMessage("devtools_panel.inspectedWindow_eval_callback")
+  ]);
+
+  info("devtools_panel created, loaded and inspectedWindow eval executed")
+
+  info("test complete");
+
+  yield extension.unload();
+  yield gDevTools.closeToolbox(target);
+  yield BrowserTestUtils.removeTab(tab);
+
+  info("extension unloaded successfully");
+});
diff --git a/browser/components/extensions/test/browser/head.js b/browser/components/extensions/test/browser/head.js
index ac6f9c1..3bb1d89 100644
--- a/browser/components/extensions/test/browser/head.js
+++ b/browser/components/extensions/test/browser/head.js
@@ -1,7 +1,12 @@
 var {CustomizableUI} = Cu.import("resource:///modules/CustomizableUI.jsm");
 
 function makeWidgetId(id)
 {
   id = id.toLowerCase();
   return id.replace(/[^a-z0-9_-]/g, "_");
 }
+
+function makeDevtoolsPanelId(id, url)
+{
+  return `${makeWidgetId(id)}-${url}-devtools-panel`;
+}
diff --git a/browser/components/nsBrowserGlue.js b/browser/components/nsBrowserGlue.js
index 755b1d5..2615df8 100644
--- a/browser/components/nsBrowserGlue.js
+++ b/browser/components/nsBrowserGlue.js
@@ -586,17 +586,17 @@ BrowserGlue.prototype = {
     // gets called in finalUIStartup and from a browser-search-service observer,
     // to catch both cases (search service initialization occurring before and
     // after final-ui-startup)
     if (Services.search.isInitialized) {
       Services.search.defaultEngine = Services.search.currentEngine;
     }
   },
 
-  // initialization (called on application startup) 
+  // initialization (called on application startup)
   _init: function BG__init() {
     let os = Services.obs;
     os.addObserver(this, "notifications-open-settings", false);
     os.addObserver(this, "prefservice:after-app-defaults", false);
     os.addObserver(this, "final-ui-startup", false);
     os.addObserver(this, "browser-delayed-startup-finished", false);
     os.addObserver(this, "sessionstore-windows-restored", false);
     os.addObserver(this, "browser:purge-session-history", false);
@@ -631,16 +631,17 @@ BrowserGlue.prototype = {
     os.addObserver(this, "autocomplete-did-enter-text", false);
     os.addObserver(this, "tablet-mode-change", false);
 
     ExtensionManagement.registerScript("chrome://browser/content/ext-utils.js");
     ExtensionManagement.registerScript("chrome://browser/content/ext-browserAction.js");
     ExtensionManagement.registerScript("chrome://browser/content/ext-contextMenus.js");
     ExtensionManagement.registerScript("chrome://browser/content/ext-tabs.js");
     ExtensionManagement.registerScript("chrome://browser/content/ext-windows.js");
+    ExtensionManagement.registerScript("chrome://browser/content/ext-devtools.js");
 
     this._flashHangCount = 0;
   },
 
   // cleanup (called on application shutdown)
   _dispose: function BG__dispose() {
     let os = Services.obs;
     os.removeObserver(this, "notifications-open-settings");
@@ -806,17 +807,17 @@ BrowserGlue.prototype = {
   },
 
   // runs on startup, before the first command line handler is invoked
   // (i.e. before the first window is opened)
   _finalUIStartup: function BG__finalUIStartup() {
     this._sanitizer.onStartup();
     // check if we're in safe mode
     if (Services.appinfo.inSafeMode) {
-      Services.ww.openWindow(null, "chrome://browser/content/safeMode.xul", 
+      Services.ww.openWindow(null, "chrome://browser/content/safeMode.xul",
                              "_blank", "chrome,centerscreen,modal,resizable=no", null);
     }
 
     // apply distribution customizations
     // prefs are applied in _onAppDefaults()
     this._distributionCustomizer.applyCustomizations();
 
     // handle any UI migration
@@ -2038,17 +2039,17 @@ BrowserGlue.prototype = {
       for (let resourceName of ["mode", "iconsize"]) {
         for (let toolbarId of toolbars) {
           xulStore.removeValue(BROWSER_DOCURL, toolbarId, resourceName);
         }
       }
     }
 
     if (currentUIVersion < 19) {
-      let detector = null;    
+      let detector = null;
       try {
         detector = Services.prefs.getComplexValue("intl.charset.detector",
                                                   Ci.nsIPrefLocalizedString).data;
       } catch (ex) {}
       if (!(detector == "" ||
             detector == "ja_parallel_state_machine" ||
             detector == "ruprob" ||
             detector == "ukprob")) {
@@ -2200,17 +2201,17 @@ BrowserGlue.prototype = {
         (lightweightThemeSelected && selectedThemeID != "firefox-devedition@mozilla.org");
 
       if (userChoseToNotUseDeveditionTheme && selectedThemeID == "firefox-devedition@mozilla.org") {
         Services.prefs.setCharPref("lightweightThemes.selectedThemeID", "");
       }
 
       Services.prefs.clearUserPref("browser.devedition.showCustomizeButton");
     }
- 
+
     if (currentUIVersion < 31) {
       xulStore.removeValue(BROWSER_DOCURL, "bookmarks-menu-button", "class");
       xulStore.removeValue(BROWSER_DOCURL, "home-button", "class");
     }
 
     // Update the migration version.
     Services.prefs.setIntPref("browser.migration.version", UI_VERSION);
   },
diff --git a/devtools/server/actors/webconsole.js b/devtools/server/actors/webconsole.js
index d0685ea..0755faa 100644
--- a/devtools/server/actors/webconsole.js
+++ b/devtools/server/actors/webconsole.js
@@ -799,23 +799,31 @@ WebConsoleActor.prototype =
 
     // First, send a response packet with the id only.
     let resultID = Date.now();
     this.conn.send({
       from: this.actorID,
       resultID: resultID
     });
 
-    // Then, execute the script that may pause.
-    let response = this.onEvaluateJS(aRequest);
-    response.resultID = resultID;
+    // Then, execute the script that may pause
+    let evaluate = () => {
+      let response = this.onEvaluateJS(aRequest);
+      response.resultID = resultID;
+
+      // Finally, send an unsolicited evaluationResult packet with
+      // the normal return value
+      this.conn.sendActorEvent(this.actorID, "evaluationResult", response);
+    };
 
-    // Finally, send an unsolicited evaluationResult packet with
-    // the normal return value
-    this.conn.sendActorEvent(this.actorID, "evaluationResult", response);
+    if (aRequest.runOnNextWindowReady) {
+      events.once(this.parentActor, "window-ready", evaluate);
+    } else {
+      evaluate();
+    }
   },
 
   /**
    * Handler for the "evaluateJS" request. This method evaluates the given
    * JavaScript string and sends back the result.
    *
    * @param object aRequest
    *        The JSON request object received from the Web Console client.
@@ -859,25 +867,36 @@ WebConsoleActor.prototype =
     try {
       resultGrip = this.createValueGrip(result);
     } catch (e) {
       errorMessage = e;
     }
 
     this._lastConsoleInputEvaluation = result;
 
-    return {
+    let ret = {
       from: this.actorID,
       input: input,
       result: resultGrip,
       timestamp: timestamp,
       exception: errorGrip,
       exceptionMessage: this._createStringGrip(errorMessage),
       helperResult: helperResult,
     };
+
+    if (aRequest.unsafeDereference) {
+      let value = result && result.type === "undefined" ?
+        undefined : result;
+      value = value && (typeof value.unsafeDereference == "function") ?
+        value.unsafeDereference() : value;
+
+      ret.plainResult = value;
+    }
+
+    return ret;
   },
 
   /**
    * The Autocomplete request handler.
    *
    * @param object aRequest
    *        The request message - what input to autocomplete.
    * @return object
diff --git a/devtools/shared/webconsole/client.js b/devtools/shared/webconsole/client.js
index 86fe803..b47f0b8 100644
--- a/devtools/shared/webconsole/client.js
+++ b/devtools/shared/webconsole/client.js
@@ -250,16 +250,17 @@ WebConsoleClient.prototype = {
     let packet = {
       to: this._actor,
       type: "evaluateJS",
       text: aString,
       bindObjectActor: aOptions.bindObjectActor,
       frameActor: aOptions.frameActor,
       url: aOptions.url,
       selectedNodeActor: aOptions.selectedNodeActor,
+      unsafeDereference: aOptions.unsafeDereference,
     };
     this._client.request(packet, aOnResponse);
   },
 
   /**
    * Evaluate a JavaScript expression asynchronously.
    * See evaluateJS for parameter and response information.
    */
@@ -274,16 +275,18 @@ WebConsoleClient.prototype = {
     let packet = {
       to: this._actor,
       type: "evaluateJSAsync",
       text: aString,
       bindObjectActor: aOptions.bindObjectActor,
       frameActor: aOptions.frameActor,
       url: aOptions.url,
       selectedNodeActor: aOptions.selectedNodeActor,
+      unsafeDereference: aOptions.unsafeDereference,
+      runOnNextWindowReady: aOptions.runOnNextWindowReady,
     };
 
     this._client.request(packet, response => {
       // Null check this in case the client has been detached while waiting
       // for a response.
       if (this.pendingEvaluationResults) {
         this.pendingEvaluationResults.set(response.resultID, aOnResponse);
       }

