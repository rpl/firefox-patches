# HG changeset patch
# User Luca Greco <luca.greco@alcacoop.it>

CHECK - check allowCrossOriginArguments Cu.exportFunction option on getManifest crash in debug build after extension unload

---
 toolkit/components/extensions/ExtensionContent.jsm |  8 +++++---
 toolkit/components/extensions/ExtensionUtils.jsm   | 10 +++++++---
 2 files changed, 12 insertions(+), 6 deletions(-)

diff --git a/toolkit/components/extensions/ExtensionContent.jsm b/toolkit/components/extensions/ExtensionContent.jsm
index 72f991d..5d52627 100644
--- a/toolkit/components/extensions/ExtensionContent.jsm
+++ b/toolkit/components/extensions/ExtensionContent.jsm
@@ -267,19 +267,21 @@ ExtensionContext.prototype = {
   injectAPIIntoContentWindow() {
     // Do not inject content script APIs if the document loaded has not an addon id.
     if (!ExtensionManagement.getAddonIdForWindow(this.contentWindow)) {
       return false;
     }
 
     let chromeObj = Cu.waiveXrays(this.sandbox).browser;
 
-    chromeObj = Cu.cloneInto(chromeObj, this.contentWindow, { cloneFunctions: true });
-    Cu.waiveXrays(this.contentWindow).browser = chromeObj;
-    Cu.waiveXrays(this.contentWindow).chrome = chromeObj;
+    let iframeChromeObj = Cu.createObjectIn(this.contentWindow, {defineAs: "browser"});
+    injectAPI(chromeObj, iframeChromeObj, { allowCallbacks: false, allowCrossOriginArguments: true });
+
+    Cu.waiveXrays(this.contentWindow).browser = iframeChromeObj;
+    Cu.waiveXrays(this.contentWindow).chrome = iframeChromeObj;
 
     this.contentWindowAPI = true;
 
     return true;
   },
 
   execute(script, shouldRun) {
     script.tryInject(this.extension, this.contentWindow, this.sandbox, shouldRun);
diff --git a/toolkit/components/extensions/ExtensionUtils.jsm b/toolkit/components/extensions/ExtensionUtils.jsm
index 5bb3498..9809437 100644
--- a/toolkit/components/extensions/ExtensionUtils.jsm
+++ b/toolkit/components/extensions/ExtensionUtils.jsm
@@ -432,29 +432,33 @@ function ignoreEvent(context, name) {
       consoleService.logMessage(scriptError);
     },
     removeListener: function(callback) {},
     hasListener: function(callback) {},
   };
 }
 
 // Copy an API object from |source| into the scope |dest|.
-function injectAPI(source, dest) {
+function injectAPI(source, dest, exportFunctionOptions = {}) {
+  let { allowCallbacks, allowCrossOriginArguments } = exportFunctionOptions;
+  allowCallbacks = allowCallbacks || false;
+  allowCrossOriginArguments = allowCrossOriginArguments || false;
+
   for (let prop in source) {
     // Skip names prefixed with '_'.
     if (prop[0] == "_") {
       continue;
     }
 
     let value = source[prop];
     if (typeof(value) == "function") {
-      Cu.exportFunction(value, dest, {defineAs: prop});
+      Cu.exportFunction(value, dest, {defineAs: prop, allowCallbacks, allowCrossOriginArguments});
     } else if (typeof(value) == "object") {
       let obj = Cu.createObjectIn(dest, {defineAs: prop});
-      injectAPI(value, obj);
+      injectAPI(value, obj, exportFunctionOptions);
     } else {
       dest[prop] = value;
     }
   }
 }
 
 /*
  * Messaging primitives.

