# HG changeset patch
# User Luca Greco <luca.greco@alcacoop.it>

Bug 1214658 - enable content script APIs into sub-frames pointed to a valid add-on url r=kmag

---
 toolkit/components/extensions/Extension.jsm        | 20 ++---
 toolkit/components/extensions/ExtensionContent.jsm | 89 ++++++++++++++++++----
 .../components/extensions/ExtensionManagement.jsm  | 52 +++++++++++--
 3 files changed, 131 insertions(+), 30 deletions(-)

diff --git a/toolkit/components/extensions/Extension.jsm b/toolkit/components/extensions/Extension.jsm
index a38d13c..3985cb0 100644
--- a/toolkit/components/extensions/Extension.jsm
+++ b/toolkit/components/extensions/Extension.jsm
@@ -358,22 +358,26 @@ GlobalManager = {
         },
         hasListener(ns, name, listener) {
           return schemaApi[ns][name].hasListener.call(null, listener);
         },
       };
       Schemas.inject(chromeObj, schemaWrapper);
     };
 
-    // Find the add-on associated with this document via the
-    // principal's originAttributes. This value is computed by
-    // extensionURIToAddonID, which ensures that we don't inject our
-    // API into webAccessibleResources or remote web pages.
-    let principal = contentWindow.document.nodePrincipal;
-    let id = principal.originAttributes.addonId;
+    let id = ExtensionManagement.getAddonIdForWindow(contentWindow);
+
+    // We don't inject privileged APIs into sub-frames of a UI page.
+    const { FULL_PRIVILEGES } = ExtensionManagement.API_LEVELS;
+    if (ExtensionManagement.getAPILevelForWindow(contentWindow, id) !== FULL_PRIVILEGES) {
+      return;
+    }
+
+    // We don't inject privileged APIs if the addonId is null
+    // or doesn't exist.
     if (!this.extensionMap.has(id)) {
       return;
     }
 
     let docShell = contentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
                                 .getInterface(Ci.nsIWebNavigation)
                                 .QueryInterface(Ci.nsIDocShellTreeItem)
                                 .sameTypeRootTreeItem
@@ -382,20 +386,16 @@ GlobalManager = {
     if (this.docShells.has(docShell)) {
       let {extension, context} = this.docShells.get(docShell);
       if (context && extension.id == id) {
         inject(extension, context);
       }
       return;
     }
 
-    // We don't inject into sub-frames of a UI page.
-    if (contentWindow != contentWindow.top) {
-      return;
-    }
     let extension = this.extensionMap.get(id);
     let uri = contentWindow.document.documentURIObject;
     let incognito = PrivateBrowsingUtils.isContentWindowPrivate(contentWindow);
     let context = new ExtensionPage(extension, {type: "tab", contentWindow, uri, docShell, incognito});
     inject(extension, context);
 
     let eventHandler = docShell.chromeEventHandler;
     let listener = event => {
diff --git a/toolkit/components/extensions/ExtensionContent.jsm b/toolkit/components/extensions/ExtensionContent.jsm
index bcc2c95..86355c9 100644
--- a/toolkit/components/extensions/ExtensionContent.jsm
+++ b/toolkit/components/extensions/ExtensionContent.jsm
@@ -211,17 +211,19 @@ function getWindowMessageManager(contentWindow) {
   }
 }
 
 var ExtensionManager;
 
 // Scope in which extension content script code can run. It uses
 // Cu.Sandbox to run the code. There is a separate scope for each
 // frame.
-function ExtensionContext(extensionId, contentWindow) {
+function ExtensionContext(extensionId, contentWindow, contextOptions = {}) {
+  let { isExtensionPage } = contextOptions;
+
   this.extension = ExtensionManager.get(extensionId);
   this.extensionId = extensionId;
   this.contentWindow = contentWindow;
 
   this.onClose = new Set();
 
   let utils = contentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
                            .getInterface(Ci.nsIDOMWindowUtils);
@@ -238,44 +240,65 @@ function ExtensionContext(extensionId, contentWindow) {
   if (ssm.isSystemPrincipal(contentPrincipal)) {
     // Make sure we don't hand out the system principal by accident.
     prin = Cc["@mozilla.org/nullprincipal;1"].createInstance(Ci.nsIPrincipal);
   } else {
     let extensionPrincipal = ssm.createCodebasePrincipal(this.extension.baseURI, {addonId: extensionId});
     prin = [contentPrincipal, extensionPrincipal];
   }
 
-  this.sandbox = Cu.Sandbox(prin, {
-    sandboxPrototype: contentWindow,
-    wantXrays: true,
-    isWebExtensionContentScript: true,
-    wantGlobalProperties: ["XMLHttpRequest"],
-  });
+  if (isExtensionPage) {
+    if (ExtensionManagement.getAddonIdForWindow(this.contentWindow) != extensionId) {
+      throw new Error("Invalid target window for this extension context");
+    }
+    // This is an iframe with content script API enabled and its principal should be the
+    // contentWindow itself. (See Bug 1214658 for rationale)
+    this.sandbox = Cu.Sandbox(contentWindow, {
+      sandboxPrototype: contentWindow,
+      wantXrays: false,
+      isWebExtensionContentScript: true,
+    });
+  } else {
+    this.sandbox = Cu.Sandbox(prin, {
+      sandboxPrototype: contentWindow,
+      wantXrays: true,
+      isWebExtensionContentScript: true,
+      wantGlobalProperties: ["XMLHttpRequest"],
+    });
+  }
 
   let delegate = {
     getSender(context, target, sender) {
       // Nothing to do here.
     },
   };
 
   let url = contentWindow.location.href;
   let broker = ExtensionContent.getBroker(mm);
   // The |sender| parameter is passed directly to the extension.
   let sender = {id: this.extension.uuid, frameId, url};
   // Properties in |filter| must match those in the |recipient|
   // parameter of sendMessage.
   let filter = {extensionId, frameId};
   this.messenger = new Messenger(this, broker, sender, filter, delegate);
 
-  let chromeObj = Cu.createObjectIn(this.sandbox, {defineAs: "browser"});
+  this.chromeObj = Cu.createObjectIn(this.sandbox, {defineAs: "browser"});
 
   // Sandboxes don't get Xrays for some weird compatibility
   // reason. However, we waive here anyway in case that changes.
-  Cu.waiveXrays(this.sandbox).chrome = Cu.waiveXrays(this.sandbox).browser;
-  injectAPI(api(this), chromeObj);
+  Cu.waiveXrays(this.sandbox).chrome = this.chromeObj;
+
+  injectAPI(api(this), this.chromeObj);
+
+  // This is an iframe with content script API enabled. (See Bug 1214658 for rationale)
+  if (isExtensionPage) {
+    this.isExtensionPage = isExtensionPage;
+    Cu.waiveXrays(this.contentWindow).chrome = this.chromeObj;
+    Cu.waiveXrays(this.contentWindow).browser = this.chromeObj;
+  }
 }
 
 ExtensionContext.prototype = {
   get cloneScope() {
     return this.sandbox;
   },
 
   execute(script, shouldRun) {
@@ -289,17 +312,26 @@ ExtensionContext.prototype = {
   forgetOnClose(obj) {
     this.onClose.delete(obj);
   },
 
   close() {
     for (let obj of this.onClose) {
       obj.close();
     }
+
+    // Overwrite the content script APIs with an empty object if the APIs objects are still
+    // defined in the content window (See Bug 1214658 for rationale).
+    if (this.isExtensionPage && Cu.waiveXrays(this.contentWindow).browser === this.chromeObj) {
+      Cu.createObjectIn(this.contentWindow, { defineAs: "browser" });
+      Cu.createObjectIn(this.contentWindow, { defineAs: "chrome" });
+    }
+
     Cu.nukeSandbox(this.sandbox);
+    this.sandbox = null;
   },
 };
 
 function windowId(window) {
   return window.QueryInterface(Ci.nsIInterfaceRequestor)
                .getInterface(Ci.nsIDOMWindowUtils)
                .currentInnerWindowID;
 }
@@ -343,16 +375,28 @@ var DocumentManager = {
 
       // Make sure we only load into frames that ExtensionContent.init
       // was called on (i.e., not frames for social or sidebars).
       let mm = getWindowMessageManager(window);
       if (!mm || !ExtensionContent.globals.has(mm)) {
         return;
       }
 
+      // Enable the content script APIs should be available in subframes' window
+      // if it is recognized as a valid addon id (see Bug 1214658 for rationale).
+      const { CONTENTSCRIPT_PRIVILEGES } = ExtensionManagement.API_LEVELS;
+      let extensionId = ExtensionManagement.getAddonIdForWindow(window);
+
+      if (ExtensionManagement.getAPILevelForWindow(window, extensionId) == CONTENTSCRIPT_PRIVILEGES &&
+          ExtensionManager.get(extensionId)) {
+        DocumentManager.createExtensionContext(extensionId, window, { isExtensionPage: true });
+
+        return;
+      }
+
       this.trigger("document_start", window);
       /* eslint-disable mozilla/balanced-listeners */
       window.addEventListener("DOMContentLoaded", this, true);
       window.addEventListener("load", this, true);
       /* eslint-enable mozilla/balanced-listeners */
     } else if (topic == "inner-window-destroyed") {
       let id = subject.QueryInterface(Ci.nsISupportsPRUint64).data;
       if (!this.windows.has(id)) {
@@ -408,29 +452,46 @@ var DocumentManager = {
     yield [window, this.getWindowState(window)];
 
     for (let i = 0; i < docShell.childCount; i++) {
       let child = docShell.getChildAt(i).QueryInterface(Ci.nsIDocShell);
       yield* this.enumerateWindows(child);
     }
   },
 
-  getContext(extensionId, window) {
+  getExtensionsForWindow(window) {
     let winId = windowId(window);
     if (!this.windows.has(winId)) {
       this.windows.set(winId, new Map());
     }
-    let extensions = this.windows.get(winId);
+
+    return this.windows.get(winId);
+  },
+
+  getContext(extensionId, window) {
+    let extensions = this.getExtensionsForWindow(window);
     if (!extensions.has(extensionId)) {
-      let context = new ExtensionContext(extensionId, window);
-      extensions.set(extensionId, context);
+      return this.createExtensionContext(extensionId, window);
     }
+
     return extensions.get(extensionId);
   },
 
+  createExtensionContext(extensionId, window, contextOptions = {}) {
+    let extensions = this.getExtensionsForWindow(window);
+    if (extensions.has(extensionId)) {
+      throw Error("This window already had an extension context");
+    }
+
+    let context = new ExtensionContext(extensionId, window, contextOptions);
+    extensions.set(extensionId, context);
+
+    return context;
+  },
+
   startupExtension(extensionId) {
     if (this.extensionCount == 0) {
       this.init();
     }
     this.extensionCount++;
 
     let extension = ExtensionManager.get(extensionId);
     for (let global of ExtensionContent.globals.keys()) {
diff --git a/toolkit/components/extensions/ExtensionManagement.jsm b/toolkit/components/extensions/ExtensionManagement.jsm
index 36c29a7..99aa42d 100644
--- a/toolkit/components/extensions/ExtensionManagement.jsm
+++ b/toolkit/components/extensions/ExtensionManagement.jsm
@@ -197,33 +197,73 @@ var Service = {
   checkAddonMayLoad(extension, uri) {
     return extension.whiteListedHosts.matchesIgnoringPath(uri);
   },
 
   // Finds the add-on ID associated with a given moz-extension:// URI.
   // This is used to set the addonId on the originAttributes for the
   // nsIPrincipal attached to the URI.
   extensionURIToAddonID(uri) {
-    if (this.extensionURILoadableByAnyone(uri)) {
-      // We don't want webAccessibleResources to be associated with
-      // the add-on. That way they don't get any special privileges.
-      return null;
-    }
-
     let uuid = uri.host;
     let extension = this.uuidMap.get(uuid);
     return extension ? extension.id : undefined;
   },
 };
 
+// API Levels Helpers
+
+// Find the add-on associated with this document via the
+// principal's originAttributes. This value is computed by
+// extensionURIToAddonID, which ensures that we don't inject our
+// API into webAccessibleResources or remote web pages.
+function getAddonIdForWindow(window) {
+  let principal = window.document.nodePrincipal;
+  return principal.originAttributes.addonId;
+}
+
+const API_LEVELS = Object.freeze({
+  NO_PRIVILEGES: 0,
+  CONTENTSCRIPT_PRIVILEGES: 1,
+  FULL_PRIVILEGES: 2,
+});
+
+// Finds the API Level ("FULL_PRIVILEGES", "CONTENTSCRIPT_PRIVILEGES", "NO_PRIVILEGES")
+// with a given a window object.
+function getAPILevelForWindow(window, addonId) {
+  const { NO_PRIVILEGES, CONTENTSCRIPT_PRIVILEGES, FULL_PRIVILEGES } = API_LEVELS;
+
+  // Non WebExtension URLs and WebExtension URLs from a different extension
+  // has no access to APIs.
+  if (!addonId && getAddonIdForWindow(window) != addonId) {
+    return NO_PRIVILEGES;
+  }
+
+  let docShell = window.QueryInterface(Ci.nsIInterfaceRequestor)
+        .getInterface(Ci.nsIDocShell);
+
+  // WebExtension URLs loaded into sub-frame UI have "content script API level privileges".
+  // (see Bug 1214658 for rationale)
+  if (docShell.sameTypeParent) {
+    return CONTENTSCRIPT_PRIVILEGES;
+  }
+
+  // WebExtension URLs loaded into top frames UI could have full API level privileges.
+  return FULL_PRIVILEGES;
+}
+
 this.ExtensionManagement = {
   startupExtension: Service.startupExtension.bind(Service),
   shutdownExtension: Service.shutdownExtension.bind(Service),
 
   registerScript: Scripts.register.bind(Scripts),
   getScripts: Scripts.getScripts.bind(Scripts),
 
   registerSchema: Schemas.register.bind(Schemas),
   getSchemas: Schemas.getSchemas.bind(Schemas),
 
   getFrameId: Frames.getId.bind(Frames),
   getParentFrameId: Frames.getParentId.bind(Frames),
+
+  // exported API Level Helpers
+  getAddonIdForWindow,
+  getAPILevelForWindow,
+  API_LEVELS,
 };

